{"pageProps":{"articlesDetail":{"year":"2023","month":"07","folder":"../md/2023-07-lodash","slug":"2023-07-lodash","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    em: \"em\",\n    strong: \"strong\",\n    ul: \"ul\",\n    li: \"li\",\n    h2: \"h2\",\n    h3: \"h3\",\n    blockquote: \"blockquote\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Lodash mudou a forma como escrevo JavaScript\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Quando iniciei em programação, aprendi inicialmente a realizar manipulações de dados\\nde forma \\\"imperativa\\\", como é comum para a maioria das pessoas.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      className: \"language-js\",\n      children: _jsxs(_components.code, {\n        className: \"language-js\",\n        children: [_jsx(_components.span, {\n          className: \"token comment\",\n          children: \"// operação de mapeamento escrita de forma imperativa\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"token keyword\",\n          children: \"const\"\n        }), \" output \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"[\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"]\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"token keyword control-flow\",\n          children: \"for\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), _jsx(_components.span, {\n          className: \"token keyword\",\n          children: \"const\"\n        }), \" item \", _jsx(_components.span, {\n          className: \"token keyword\",\n          children: \"of\"\n        }), \" source\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"{\"\n        }), \"\\n  output\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \".\"\n        }), _jsx(_components.span, {\n          className: \"token method function property-access\",\n          children: \"push\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"{\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token spread operator\",\n          children: \"...\"\n        }), \"item\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \",\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token literal-property property\",\n          children: \"hello\"\n        }), _jsx(_components.span, {\n          className: \"token operator\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token string\",\n          children: \"'world'\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"}\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"}\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"token comment\",\n          children: \"// modo funcional\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"token keyword\",\n          children: \"const\"\n        }), \" output \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"=\"\n        }), \" source\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \".\"\n        }), _jsx(_components.span, {\n          className: \"token method function property-access\",\n          children: \"map\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), _jsx(_components.span, {\n          className: \"token parameter\",\n          children: \"item\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token arrow operator\",\n          children: \"=>\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"{\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"token keyword control-flow\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"{\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token spread operator\",\n          children: \"...\"\n        }), \"item\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \",\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token literal-property property\",\n          children: \"hello\"\n        }), _jsx(_components.span, {\n          className: \"token operator\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token string\",\n          children: \"'world'\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"}\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"}\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Ler a documentação da antiga biblioteca \", _jsx(_components.em, {\n        children: \"underscore\"\n      }), \" me fez perceber que muitos padrões\\nde manipulação de dados podem ser encapsulados em funções. Seguindo este caminho, as manipulações, ao invés de serem escritas no modo \\\"imperativo\\\" (como na imagem acima), podem ser escritas a partir da \", _jsx(_components.strong, {\n        children: \"composição\"\n      }), \" de funções comuns.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Imperativo vs. funcional\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"No modo imperativo, você geralmente inicia um loop declarando a sua saída de antemão (como no exemplo acima);\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Você não tem como saber se a operação é um \", _jsx(_components.em, {\n          children: \"map\"\n        }), \" ou um \", _jsx(_components.em, {\n          children: \"reduce\"\n        }), \" sem ler o conteúdo do loop for inteiro; Um loop é uma construção mais genérica do que uma função pré-determinada -- isto torna a leitura mais tediosa;\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"No modo funcional, a saída é o \", _jsx(_components.em, {\n          children: \"retorno\"\n        }), \" de uma função;\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"No modo funcional você precisa declarar menos tipos. Eles são determinados via inferência a partir da função e de sua entrada;\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Funções são construções menos genéricas, sua saída é mais específica e previsível do que a de um loop for -- isto facilita a leitura;\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Quais funções do Lodash mais utilizo?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"O Lodash possui centenas de funções, algumas mais úteis do que outras, muitas delas hoje integradas ao núcleo do JS. Listo aqui algumas que uso bastante:\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: _jsx(_components.code, {\n        children: \"[].keyBy(...)\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Indexar um \", _jsx(_components.em, {\n        children: \"array\"\n      }), \" de acordo com uma propriedade ou um predicado.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Se você quer frequentemente \", _jsx(_components.em, {\n        children: \"procurar\"\n      }), \" um item dentro de um array mas quer evitar gerar uma operação O(n^2), provavelmente é mais eficiente \", _jsx(_components.em, {\n        children: \"indexar\"\n      }), \" a coleção de antemão, criando assim um hash map.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"X[] --> { string : X }\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: _jsx(_components.code, {\n        children: \"[].groupBy(...)\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Similar ao \", _jsx(_components.code, {\n        children: \"keyBy()\"\n      }), \", mas reconhecendo que podem ocorrer múltiplas instâncias de uma chave selecionada. Desta forma, ao final ta operação, é gerado um objeto do tipo \", _jsx(_components.code, {\n        children: \"Record<string, X[]>\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Um ponto interessante do \", _jsx(_components.code, {\n        children: \"groupBy()\"\n      }), \" é que os ganhos de clareza do código são grandes. A versão imperativa de um \", _jsx(_components.em, {\n        children: \"groupBy\"\n      }), \" é um código de volume considerável e leitura pesada.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"X[] --> { string: X[] }\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [_jsx(_components.code, {\n        children: \"{}.toPairs()\"\n      }), \" e \", _jsx(_components.code, {\n        children: \"[].fromPairs()\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Estas funções agora possuem suas versões na biblioteca JS: \", _jsx(_components.code, {\n        children: \"Object.entries()\"\n      }), \" e \", _jsx(_components.code, {\n        children: \"Object.fromEntries()\"\n      }), \", que devem ser utilizadas ao invés das versões Lodash.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Classicamente no JS, pra iterar em um objeto você poderia utilizar \", _jsx(_components.code, {\n        children: \"Object.keys()\"\n      }), \" ou \", _jsx(_components.code, {\n        children: \"for .. in\"\n      }), \" (*). A vantagem do uso do \", _jsx(_components.em, {\n        children: \"pairs\"\n      }), \" é a sintaxe mais sucinta, e também que você passa a contar com os métodos de arrays (\", _jsx(_components.code, {\n        children: \".map\"\n      }), \", \", _jsx(_components.code, {\n        children: \".filter\"\n      }), \", etc).\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: _jsx(_components.code, {\n        children: \"[].sortBy(...)\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Geralmente a função \", _jsx(_components.code, {\n        children: \".sort()\"\n      }), \" padrão do JS necessita que escrevamos uma função de comparação de pelo menos umas 3 linhas para ser usada em coleções. Do MDN:\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"The sort() method sorts the elements of an array in place and returns the reference to the same array, now sorted. The default sort order is ascending, built upon converting the elements into strings, then comparing their sequences of UTF-16 code units values.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Já com o \", _jsx(_components.code, {\n        children: \"sortBy\"\n      }), \" podemos simplesmente passar uma chave, além de esta operação não ser feita \", _jsx(_components.em, {\n        children: \"in-place\"\n      }), \" (ela não muta o objeto de origem).\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: _jsx(_components.code, {\n        children: \"[].uniq(...)\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: _jsx(_components.code, {\n        children: \"[].isEqual(...)\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Comparação \", _jsx(_components.em, {\n        children: \"deep\"\n      }), \" entre objetos.\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [_jsx(_components.code, {\n        children: \"[].difference(...)\"\n      }), \" e \", _jsx(_components.code, {\n        children: \"[].intersection()\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Operação entre conjuntos, usada - por exemplo - pra determinar novos itens ou itens excluídos.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Métodos de array JS\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Os métodos de array são o feijão com arroz da programação (semi)funcional de JS e intercalam bem com os helpers do Lodash. Em um passado remoto eles não faziam parte do JS e tínhamos que usar versões externas (como as do Lodash).\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"[].find()\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"[].map()\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"[].filter()\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"[].reduce()\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"[].flat()\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"[].flatMap()\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"[].some()\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"[].every()\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"...\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Além do uso de funções\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"O conhecimento de padrões funcionais me facilita na leitura de codebases imperativas. Por exemplo, identifico blocos de código que agem como funções...\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\\"Essas 30 linhas são um \", _jsx(_components.code, {\n          children: \".map\"\n        }), \"\\\"\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\\"Essas outras 30 linhas são um \", _jsx(_components.code, {\n          children: \".reduce\"\n        }), \"\\\"\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"\\\"You may not need Lodash\\\"\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Algumas críticas comuns ao uso do Lodash:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Algumas de suas funções podem ser implementadas de forma próxima por códigos curtos (ex: one-liners);\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"As implementações podem ser mais complexas e menos performáticas do que se imagina, devido ao tratamento de \", _jsx(_components.em, {\n          children: \"edge cases\"\n        }), \";\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Os módulos do Lodash não se dão (ou não se davam bem) com \", _jsx(_components.em, {\n          children: \"code-splitting\"\n        }), \", gerando bundles maiores do que o necessário. Em determinada época era necessário um plugin para Webpack pra otimizar o tamanho do bundle, não sei como está hoje;\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"O Lodash \\\"base\\\" não é totalmente orientado a programação funcional, ao contrário de alternativas como o Ramda;\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"O código escrito usando helpers pode ser menos performático;\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Em geral o que acho importante aqui é perceber como os padrões de programação imperativa aos quais estamos acostumados são blocos bem repetitivos que podem ser extraídos em funções menores, independentemente de como isto for feito.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"wikiLinks":[],"title":"Lodash mudou a forma como escrevo JavaScript","backlinks":[]}},"__N_SSG":true}