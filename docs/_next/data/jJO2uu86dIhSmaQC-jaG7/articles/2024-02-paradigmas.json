{"pageProps":{"articlesDetail":{"year":"2024","month":"02","folder":"../md/2024-02-paradigmas","slug":"2024-02-paradigmas","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    h2: \"h2\",\n    ul: \"ul\",\n    li: \"li\",\n    code: \"code\",\n    pre: \"pre\",\n    strong: \"strong\",\n    span: \"span\",\n    em: \"em\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Paradigmas de programação\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Estava ouvindo uma conversa sobre paradigmas de programação e resolvi dar meus 2 centavos sobre o\\nassunto, sempre tentando ser super breve.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Procedural\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Procedural equivale mais ou menos ao estilo de código usado na linguagem C, especialmente em\\nbibliotecas mais antigas. O código procedural consiste de funções, o que pode levar à sua confusão\\ncom o paradigma funcional, mas existem diferenças.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"Em bibliotecas antigas, com a ausência de recursos de agrupamento, era muito comum o emprego\\nde prefixos em nomes de funções para denotar agrupamento. Exemplo: \", _jsx(_components.code, {\n            children: \"str_\"\n          }), \", \", _jsx(_components.code, {\n            children: \"mem_\"\n          }), \", \", _jsx(_components.code, {\n            children: \"file_\"\n          }), \";\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Argumentos comuns entre funções podem ser agrupados em \\\"structs\\\" (como objetos das linguagens\\nmodernas);\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Exemplo hipotético:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"File handle = file_open(\\\"arquivo.txt\\\");\\nstring* s = file_read(handle, 200)\\nfile_append(handle, \\\"abc\\\")\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Orientação a objeto\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"O objeto é uma estrutura agrupadora que confere algumas propriedades de organização que discutiremos\\nadiante. As linhas de código do exemplo anterior poderiam ser escritas dessa forma:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"File file = new File(\\\"arquivo.txt\\\");\\nstring* s = file.read(200)\\nfile.append(\\\"abc\\\")\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Não precisamos mais de prefixos para organizar as funções;\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Ao invés de termos a variável \", _jsx(_components.code, {\n          children: \"handle\"\n        }), \" passada como primeiro argumento de todas as funções, ela\\né agora armazenada como estado interno do objeto e omitida dos argumentos;\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Logo, uma propriedade importante de um objeto é que ele pode armazenar um estado interno. Em um\\ncódigo C antigo, esse estado interno ao invés disso moraria em uma variável que é exaustivamente\\npassada no primeiro argumento de toda função.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Outra propriedade importante da orientação a objetos é o poder de \", _jsx(_components.strong, {\n        children: \"substituição\"\n      }), \". No seguinte código\\nJS:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      className: \"language-js\",\n      children: _jsxs(_components.code, {\n        className: \"language-js\",\n        children: [_jsx(_components.span, {\n          className: \"token keyword\",\n          children: \"const\"\n        }), \" somador \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"{\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"token function\",\n          children: \"rodar\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), _jsx(_components.span, {\n          className: \"token parameter\",\n          children: \"num\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"{\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"token keyword\",\n          children: \"const\"\n        }), \" resultado1 \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token keyword\",\n          children: \"this\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \".\"\n        }), _jsx(_components.span, {\n          className: \"token method function property-access\",\n          children: \"calcular\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), \"num\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"token keyword\",\n          children: \"const\"\n        }), \" resultado2 \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token keyword\",\n          children: \"this\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \".\"\n        }), _jsx(_components.span, {\n          className: \"token method function property-access\",\n          children: \"coisar\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), \"resultado1\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"token keyword control-flow\",\n          children: \"return\"\n        }), \" resultado2\\n  \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"}\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \",\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"token function\",\n          children: \"calcular\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), _jsx(_components.span, {\n          className: \"token parameter\",\n          children: \"num\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"{\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"token keyword control-flow\",\n          children: \"return\"\n        }), \" num \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"*\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token number\",\n          children: \"2\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"}\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \",\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"token function\",\n          children: \"coisar\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), _jsx(_components.span, {\n          className: \"token parameter\",\n          children: \"num\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"{\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"token keyword control-flow\",\n          children: \"return\"\n        }), \" num\\n  \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"}\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"}\"\n        }), \"\\n\\nsomador\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \".\"\n        }), _jsx(_components.span, {\n          className: \"token method function property-access\",\n          children: \"rodar\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), _jsx(_components.span, {\n          className: \"token number\",\n          children: \"2\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token comment\",\n          children: \"// 4\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"O procedimento \", _jsx(_components.code, {\n        children: \"rodar()\"\n      }), \" é dividido em sub-etapas \", _jsx(_components.code, {\n        children: \"calcular()\"\n      }), \" e \", _jsx(_components.code, {\n        children: \"coisar()\"\n      }), \". Graças à disposição\\nem objeto, temos a flexibilidade de sobrescrever essas sub-etapas individualmente para compor novas rotinas.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      className: \"language-js\",\n      children: _jsxs(_components.code, {\n        className: \"language-js\",\n        children: [_jsx(_components.span, {\n          className: \"token keyword\",\n          children: \"const\"\n        }), \" somador2 \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token known-class-name class-name\",\n          children: \"Object\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \".\"\n        }), _jsx(_components.span, {\n          className: \"token method function property-access\",\n          children: \"create\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), \"somador\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \"\\nsomador2\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \".\"\n        }), _jsx(_components.span, {\n          className: \"token method-variable function-variable method function property-access\",\n          children: \"coisar\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token keyword\",\n          children: \"function\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), _jsx(_components.span, {\n          className: \"token parameter\",\n          children: \"num\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"{\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"token keyword control-flow\",\n          children: \"return\"\n        }), \" num \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"*\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token number\",\n          children: \"3\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"}\"\n        }), \"\\n\\nsomador2\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \".\"\n        }), _jsx(_components.span, {\n          className: \"token method function property-access\",\n          children: \"rodar\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), _jsx(_components.span, {\n          className: \"token number\",\n          children: \"2\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token comment\",\n          children: \"// 12\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Na orientação a objetos é extremamente comum a criação de novos procedimentos a partir da \", _jsx(_components.em, {\n        children: \"substituição\"\n      }), \"\\n(overriding) de partes de outros procedimentos.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Programação funcional\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Além do uso de funções, a programação funcional abraça a imutabilidade e a ausência de efeitos\\ncolaterais (side-effects), o que é muito interessante pra aplicações de processamento paralelo.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Dada uma função:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"f(x) -> y\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Para uma determinada função f, e um dado x, o resultado y será sempre o mesmo;\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"A execução de \", _jsx(_components.code, {\n          children: \"f()\"\n        }), \" não altera nenhuma variável fora de seu escopo; \", _jsx(_components.code, {\n          children: \"f()\"\n        }), \" é uma caixa-preta\\nisolada; \", _jsx(_components.code, {\n          children: \"f()\"\n        }), \" é dita uma função pura;\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"A exigência de imutabilidade faz a programação funcional diferir vastamente do paradigma procedural,\\npois naquele é comum a mutação de argumentos de funções.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      className: \"language-php\",\n      children: _jsxs(_components.code, {\n        className: \"language-php\",\n        children: [_jsx(_components.span, {\n          className: \"token comment\",\n          children: \"// procedural\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"token keyword type-declaration\",\n          children: \"string\"\n        }), \" src \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token string single-quoted-string\",\n          children: \"'abc'\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"token function\",\n          children: \"str_concat\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), \"src\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \",\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token string single-quoted-string\",\n          children: \"'d'\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"token keyword\",\n          children: \"print\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), \"src\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token comment\",\n          children: \"// abcd\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Em linguagens puramente funcionais, mesmo pilares básicos como estruturas de controle de fluxo são\\nrepensados para atingir e suportar a imutabilidade. Por exemplo, não existe \", _jsx(_components.code, {\n        children: \"for\"\n      }), \" ou \", _jsx(_components.code, {\n        children: \"if\"\n      }), \" propriamente ditos em uma linguagem puramente funcional.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"A rigidez de linguagens funcionais permite a criação de sistemas de tipos altamente precisos\\nna identificação de erros em tempo de compilação.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Linguagens funcionais são focadas em combinar código através da\\n\\\"composição\\\", que é o ato de combinar várias funções simples para gerar uma complexa, passando uma\\ncomo argumento de outra.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"h(x) = f(g(x))\\nh : f g\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Uma técnica de composição da programação funcional é o \\\"currying\\\",\\nonde uma função de 2+ argumentos é convertida em múltiplas funções de 1 argumento.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      className: \"language-js\",\n      children: _jsxs(_components.code, {\n        className: \"language-js\",\n        children: [_jsx(_components.span, {\n          className: \"token comment\",\n          children: \"// javascript\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"token comment\",\n          children: \"// somar: num -> num -> num\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"token keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token function\",\n          children: \"somar\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), _jsx(_components.span, {\n          className: \"token parameter\",\n          children: \"a\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"{\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"token keyword control-flow\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), _jsx(_components.span, {\n          className: \"token parameter\",\n          children: \"b\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"{\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"token keyword control-flow\",\n          children: \"return\"\n        }), \" a \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"+\"\n        }), \" b\\n  \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"}\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"}\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"token function\",\n          children: \"somar\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), _jsx(_components.span, {\n          className: \"token number\",\n          children: \"2\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), _jsx(_components.span, {\n          className: \"token number\",\n          children: \"3\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token comment\",\n          children: \"// 5\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"token keyword\",\n          children: \"const\"\n        }), \" somar5 \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token function\",\n          children: \"somar\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), _jsx(_components.span, {\n          className: \"token number\",\n          children: \"5\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token comment\",\n          children: \"// somar5: num -> num\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"token function\",\n          children: \"somar5\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), _jsx(_components.span, {\n          className: \"token number\",\n          children: \"3\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token comment\",\n          children: \"// 8\"\n        }), \"\\n\"]\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"wikiLinks":[],"title":"Paradigmas de programação","backlinks":[]}},"__N_SSG":true}