{"pageProps":{"articlesDetail":{"year":"2022","month":"08","folder":"../md/2022-08-react-data-fetching","slug":"2022-08-react-data-fetching","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    blockquote: \"blockquote\",\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    ul: \"ul\",\n    li: \"li\",\n    em: \"em\",\n    code: \"code\",\n    img: \"img\",\n    ol: \"ol\",\n    del: \"del\",\n    pre: \"pre\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Resumo do resumo: Data Fetching in React\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"yet another React post...\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Resumo do vídeo \", _jsx(_components.a, {\n        href: \"https://www.youtube.com/watch?v=Ao8F3FypsbI\",\n        children: \"Data Fetching in React\"\n      }), \", do \", _jsx(_components.a, {\n        href: \"https://twitter.com/t3dotgg\",\n        children: \"Theo Browne\"\n      }), \". Thanks Theo.\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"O artigo é um misto de afirmações minhas e do autor do vídeo. Não assuma antes de checar.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Prólogo: Coisas das quais não vamos falar\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Se você deseja simplesmente buscar dados sem muita preocupação, e pricipalmente evitando dezenas de futuras armadinhas, use o \", _jsx(_components.a, {\n          href: \"https://tanstack.com/query/v4/docs/overview\",\n          children: \"Tanstack Query\"\n        }), \";\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://swr.vercel.app/\",\n          children: \"useSWR (da Vercel)\"\n        }), \" é uma segunda alternativa, porém menos completa e não muito menor em tamanho;\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"Nestas bibliotecas, para cada consulta você fornece um \", _jsx(_components.em, {\n          children: \"identificador único\"\n        }), \", que serve como base para múltiplos recursos como a deduplicação de múltiplas chamadas para a mesma API, cache, etc.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Estas libs abstraem o tratamento de estados de uma solicitação assíncrona (pendente, erro, pronto), possuem auxiliadores para paginação, atualizam dados automaticamente em mutações; e tratam os dados como vivos, fazendo polling para atualizações. Dentre outros.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"fetch\"\n        }), \" é considerado um recurso de baixo nível. Geralmente você não deve precisar usá-lo pois este já estará sendo abstraído pelo (ex.) React Query.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"... mesmo que surja um caso onde você diretamente chame o fetch, isto acontecerá em um wrapper criado por você, nunca diretamente de um \", _jsx(_components.code, {\n          children: \"useEffect\"\n        }), \";\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Existem absolutamente \", _jsx(_components.em, {\n          children: \"zero\"\n        }), \" motivos pra usar Axios. É tipo usar jQuery em 2022.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Anatomia do carregamento de uma SPA\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"Pasted%20image%2020220730143025.png\",\n        alt: \"Pasted image 20220730143025.png\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(\"span\", {\n          style: {\n            color: \"red\"\n          },\n          children: \"x\"\n        }), \" Página completamente em branco até ser recebido o HTML inicial;\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(\"span\", {\n          style: {\n            color: \"yellow\"\n          },\n          children: \"x\"\n        }), \" Navegador recebe um HTML mínimo, com instruções pra carregar a aplicação;\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(\"span\", {\n          style: {\n            color: \"yellow\"\n          },\n          children: \"x\"\n        }), \" O \", _jsx(_components.del, {\n          children: \"buraco negro\"\n        }), \" \", _jsx(_components.em, {\n          children: \"bundle\"\n        }), \" é baixado e carregado. O React inicializa e monta na tela os componentes raiz em estado de carregamento, o \\\"esqueleto 2\\\". Os componentes realizam requisições;\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(\"span\", {\n          style: {\n            color: \"yellow\"\n          },\n          children: \"x\"\n        }), \" Completadas as requisições, novos componentes filhos são exibidos. Alguns deles também precisam de mais dados, e então realizam novas requisições;\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(\"span\", {\n          style: {\n            color: \"green\"\n          },\n          children: \"x\"\n        }), \" A página está completa quando todos os filhos tiverem completados suas requisições;\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"Pasted%20image%2020220730144939.png\",\n        alt: \"Pasted image 20220730144939.png\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"O problema de carregamento em cascata\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Quando um componente filho é responsável por carregar seus próprios dados, este processo só será iniciado após a criação do componente filho. O que dependerá do carregamento prévio dos componentes pai.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"Pai:\\ngetUserInfo() --> { followedChannels: [1, 2] }\\n\\nFilho1:                Filho2:\\ngetChannel(1)          getChannel(2)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Podemos mover o carregamento dos dados filhos para o componente pai, o que não necessariamente resolve o problema. Só vai haver uma melhora se evitarmos uma viagem extra ao servidor.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"NÃO RESOLVE:\\ngetUserInfo()  --> { followedChannels: [1, 2] }\\ngetChannel(1)    getChannel(2)\\n\\nRESOLVE:\\ngetUserInfo()  --> { followedChannels: [{ ... }, { ... }] }\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"O carregamento em cascata é um \", _jsx(_components.em, {\n        children: \"tradeoff\"\n      }), \" entre simplicidade e performance. É mais \", _jsx(_components.em, {\n        children: \"simples\"\n      }), \" escrever um componente que cuide de seus próprios dados e não possua dependência externa, pois este estará mais isolado. Para você evitar o carregamento em cascata, você tem que mover partes do carregamento de dados para cima, e para o servidor.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Relay:\"\n      }), \" O \", _jsx(_components.em, {\n        children: \"Relay\"\n      }), \" é uma das poucas bibliotecas que se propõe a abstrair o problema de \\\"mover o carregamento de dados pra cima e para o servidor\\\". O Theo tem uma opinião mista sobre o Relay. Diz ele que é bem complexa, o que dá margem pra pessoas a usando errado. E possui relativamente pouco uso na comunidade. Eu ainda não peguei para testar.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"title":"Resumo do resumo: Data Fetching in React"}},"__N_SSG":true}